{"version":3,"sources":["_show_hide_control.js","rd-chart-objects.js","rd-table-objects.js","rd-table.js","sticky.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"cms.js","sourcesContent":["\n/* Show or Hide content controlled by a Radio button or Checkbox */\nfunction showHideControl(element) {\n\n  if (\n      document.querySelectorAll &&\n      Function.prototype.bind &&\n      ('classList' in document.createElement('_'))\n    ) {\n\n    var element = element;\n    var elementControlled = null;\n    setup()\n\n  }\n\n  function setup() {\n\n    var elementControlledId = element.getAttribute('aria-controls')\n    var elementName = element.getAttribute('name');\n\n    if (elementControlledId) {\n      elementControlled = document.getElementById(elementControlledId);\n    }\n\n    if (elementControlled) {\n\n      var allRadioButtonsInSameGroup = document.querySelectorAll('input[name=' + elementName + ']');\n\n      for (var i = allRadioButtonsInSameGroup.length - 1; i >= 0; i--) {\n        allRadioButtonsInSameGroup[i].addEventListener('change', inputChanged.bind(this));\n      }\n\n    }\n\n    expandOrCollapseTarget(element.checked)\n  }\n\n  function expandOrCollapseTarget(expand) {\n    if (expand) {\n      elementControlled.classList.remove('js-hidden');\n    } else {\n      elementControlled.classList.add('js-hidden');\n    }\n  }\n\n  function inputChanged(event) {\n    expandOrCollapseTarget(element.checked);\n    element.setAttribute('aria-expanded', element.checked);\n  }\n\n}\n","/**\n * Created by Tom.Ridd on 08/05/2017.\n */\nvar defaultParentColor = '#2B8CC4';\nvar defaultChildColor = '#B3CBD9';\nvar VERSION = '1.1'; // panel charts include sort option\n\nfunction barchartObject(data, primary_column, secondary_column, parent_column, order_column,\n                        chart_title, x_axis_label, y_axis_label, number_format) {\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n    if(isSimpleBarchart(secondary_column)) {\n        return barchartSingleObject(headerRow, dataRows, primary_column, parent_column, order_column, chart_title, x_axis_label, y_axis_label, number_format);\n    } else {\n        return barchartDoubleObject(headerRow, dataRows, primary_column, secondary_column, parent_column, order_column, chart_title, x_axis_label, y_axis_label, number_format);\n    }\n}\n\nfunction isSimpleBarchart(column_name) {\n    return column_name === '[None]' || column_name === null;\n}\n\nfunction barchartSingleObject(headerRow, dataRows, category_column, parent_column, order_column, chart_title, x_axis_label, y_axis_label, number_format) {\n    var indices = getIndices(headerRow, category_column, null, parent_column, order_column);\n\n    var categories = uniqueCategories(dataRows, indices['category'], indices['order']);\n    var values = _.map(categories, function(category) {\n        return valueForCategory(dataRows, indices['category'], indices['value'], indices['parent'], category);\n    });\n\n    var parents = [];\n    if(indices['parent'] !== null) {\n        parents = _.unique(_.map(dataRows, function(row) { return row[indices['parent']]; }));\n    }\n\n    return {\n        'type':'bar',\n        'title':{'text':chart_title},\n        'parent_child': indices['parent'] !== null,\n        'xAxis':{'title':{'text':x_axis_label}, 'categories':categories},\n        'yAxis':{'title':{'text':y_axis_label}},\n        'series': [{'name':category_column, 'data': values}],\n        'number_format':number_format,\n        'parents':parents,\n        'version':VERSION\n    };\n}\n\nfunction barchartDoubleObject(headerRow, dataRows, category1, category2, parent_column, order_column, chart_title, x_axis_label, y_axis_label, number_format) {\n    var indices = getIndices(headerRow, category1, category2, parent_column, order_column);\n\n    var categories = uniqueCategories(dataRows, indices['category'], indices['order']);\n\n    var series = uniqueDataInColumnMaintainOrder(dataRows, indices['secondary']);\n\n    var seriesData = [];\n    series.forEach(function(s){\n        var seriesRows = _.filter(dataRows, function(row) { return row[indices['secondary']] === s;});\n        var values = [];\n        _.forEach(categories, function(category) {\n            values.push(valueForCategory(seriesRows, indices['category'], indices['value'], indices['parent'], category));\n        });\n        seriesData.push({'name':s, 'data': values});\n    });\n\n    return {\n        'type':'bar',\n        'title':{'text': chart_title},\n        'xAxis':{'title':{'text':x_axis_label}, 'categories':categories},\n        'yAxis':{'title':{'text':y_axis_label}},\n        'series': sortChartSeries(seriesData),\n        'number_format':number_format,\n        'version':VERSION\n    };\n}\n\nfunction panelBarchartObject(data, category_column, panel_column, chart_title, x_axis_label, y_axis_label, number_format, category_order_column, panel_order_column) {\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n\n    var indices = getIndices(headerRow, category_column, panel_column, null, category_order_column, panel_order_column);\n    var categories = uniqueCategories(dataRows, indices['category'], indices['order']);\n\n    var panelValues = null;\n    if(isUndefinedOrNull(panel_order_column) || panel_order_column === '[None]') {\n        panelValues = uniqueDataInColumnMaintainOrder(dataRows, indices['secondary']);\n    } else {\n        panelValues = uniqueDataInColumnOrdered(dataRows, indices['secondary'], indices['custom'])\n    }\n\n    var panels = panelValues.map(function(panelValue) {\n        var panelRows = _.filter(dataRows, function(row) { return row[indices['secondary']] === panelValue;});\n\n        var values = categories.map(function(category) {\n           return valueForCategory(panelRows, indices['category'], indices['value'], indices['parent'], category);\n        });\n\n        return {\n            'type':'small_bar',\n            'title':{'text':panelValue},\n            'xAxis':{'title':{'text':x_axis_label}, 'categories':categories},\n            'yAxis':{'title':{'text':y_axis_label}},\n            'series': [{'name':category_column, 'data': values}],\n            'number_format':number_format\n        };\n    });\n\n    return {\n        'type': 'panel_bar_chart',\n        'title': {'text': chart_title},\n        'xAxis': {'title': {'text': x_axis_label}, 'categories': categories},\n        'yAxis': {'title': {'text': y_axis_label}},\n        'panels': panels,\n        'version':VERSION\n    }\n}\n\n\nfunction linechartObject(data, categories_column, series_column, chart_title, x_axis_label, y_axis_label, number_format, series_order_column) {\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n    var series_order_column_name = series_order_column === '[None]' ? null : series_order_column;\n\n    var indices = getIndices(headerRow, categories_column, series_column, null, null, series_order_column_name);\n    var categories = uniqueDataInColumnMaintainOrder(dataRows, indices['category']);\n    var seriesNames = uniqueDataInColumnMaintainOrder(dataRows, indices['secondary']);\n\n    /*\n    This is going to require some major refactoring down line\n    For now we are going to compromise with a degree of code ugliness, build tests, and then get to beautification\n     */\n    var series_index = indices['secondary'];\n    var series_order_index = indices['custom'];\n    if (series_order_index) {\n        var order_values = _.map(seriesNames, function(series) {\n            var index = _.findIndex(dataRows, function(row) {\n                return row[series_index] === series;\n            });\n            return dataRows[index][series_order_index];\n        });\n        seriesNames = _.map(_.sortBy(_.zip(seriesNames, order_values), function(pair) { return pair[1]; }), function(pair) { return pair[0]; });\n    }\n\n    var chartSeries = [];\n    _.forEach(seriesNames, function(seriesName) {\n        var values = [];\n        _.forEach(categories, function(category) {\n            values.push(valueForCategoryAndSeries(dataRows, indices['category'], category, indices['secondary'], seriesName, indices['value']));\n        });\n        chartSeries.push({'name':seriesName, 'data':values});\n    });\n\n    return {\n        'type':'line',\n        'title':{'text':chart_title},\n        'xAxis':{'title':{'text':x_axis_label}, 'categories':categories},\n        'yAxis':{'title':{'text':y_axis_label}},\n        'series': sortChartSeries(chartSeries),\n        'number_format':number_format,\n        'version':VERSION};\n}\n\nfunction panelLinechartObject(data, x_axis_column, panel_column, chart_title, x_axis_label, y_axis_label, number_format, panel_order_column) {\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n    var indices = getIndices(headerRow, panel_column, x_axis_column, null, null, panel_order_column);\n\n    var panelNames = null;\n    if(isUndefinedOrNull(panel_order_column) || panel_order_column === '[None]') {\n        panelNames = uniqueDataInColumnMaintainOrder(dataRows, indices['category']);\n    } else {\n        panelNames = uniqueDataInColumnOrdered(dataRows, indices['category'], indices['custom'])\n    }\n    var xAxisNames = uniqueDataInColumn(dataRows, indices['secondary']);\n\n    var panelCharts = _.map(panelNames, function(panelName) {\n            var values = _.map(xAxisNames, function(category) {\n                 return valueForCategoryAndSeries(dataRows, indices['secondary'], category, indices['category'], panelName, indices['value']);\n            });\n\n            return {'type':'line',\n                'title':{'text':panelName},\n                'xAxis':{'title':{'text':x_axis_label}, 'categories':xAxisNames},\n                'yAxis':{'title':{'text':y_axis_label}},\n                'series': [{'name':panelName, 'data':values}],\n                'number_format':number_format\n            };\n        });\n\n    return {\n        'type':'panel_line_chart',\n        'title':{'text':chart_title},\n        'panels': panelCharts,\n        'number_format':number_format,\n        'version':VERSION\n    };\n}\n\n\nfunction componentChartObject(data, grouping_column, series_column, chart_title, x_axis_label, y_axis_label, number_format, row_order_column, series_order_column) {\n\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n    var indices = getIndices(headerRow, grouping_column, series_column, null, row_order_column, series_order_column);\n\n    var groups = null;\n    if(isUndefinedOrNull(row_order_column) || row_order_column === '[None]') {\n        groups = uniqueDataInColumnMaintainOrder(dataRows, indices['category']);\n    } else {\n        groups = uniqueDataInColumnOrdered(dataRows, indices['category'], indices['order']);\n    }\n\n    var seriesNames = null;\n    if(isUndefinedOrNull(series_order_column) || series_order_column === '[None]') {\n        seriesNames = uniqueDataInColumnMaintainOrder(dataRows, indices['secondary']).reverse();\n    } else {\n        seriesNames = uniqueDataInColumnOrdered(dataRows, indices['secondary'], indices['custom']).reverse();\n    }\n\n    var chartSeries = seriesNames.map(function(seriesName)\n    {\n        var values = groups.map(function(group) {\n            return valueForCategoryAndSeries(dataRows, indices['category'], group, indices['secondary'], seriesName, indices['value'])\n        });\n        return {'name': seriesName, 'data': values};\n    });\n\n    return {\n        'type':'component',\n        'title':{'text':chart_title},\n        'xAxis':{'title':{'text':x_axis_label}, 'categories':groups},\n        'yAxis':{'title':{'text':y_axis_label}},\n        'series': chartSeries,\n        'number_format':number_format,\n        'version':VERSION\n    };\n}\n\n\nfunction uniqueCategories(dataRows, categoryIndex, orderIndex) {\n\n    if(orderIndex) {\n        return uniqueDataInColumnOrdered(dataRows, categoryIndex, orderIndex);\n    } else {\n        return uniqueDataInColumnMaintainOrder(dataRows, categoryIndex);\n    }\n}\n\nfunction valueForCategory(dataRows, categoryIndex, valueIndex, parentIndex, categoryValue) {\n\n    var rows = dataRows.filter(function(row) { return row[categoryIndex] === categoryValue });\n    if(rows.length === 0) {\n        return {y: 0, category: categoryValue};\n    } else {\n        var row = rows[0];\n        if(row[categoryIndex] === categoryValue) {\n            var valueIsNumeric = isNumber(row[valueIndex]);\n            if(parentIndex) {\n                var parentValue = row[parentIndex];\n                var relationships = {is_parent:parentValue === categoryValue,\n                    is_child: parentValue !== categoryValue, parent:parentValue};\n                if(relationships['is_parent']){\n                    return {\n                        y: valueIsNumeric ? parseFloat(row[valueIndex]) : 0,\n                        relationships: relationships,\n                        category: row[categoryIndex],\n                        color: defaultParentColor,\n                        text: valueIsNumeric ? 'number' : row[valueIndex]\n                    };\n                } else {\n                    return {\n                        y: valueIsNumeric ? parseFloat(row[valueIndex]) : 0,\n                        relationships: relationships,\n                        category: row[categoryIndex],\n                        color: defaultChildColor,\n                        text: valueIsNumeric ? 'number' : row[valueIndex]\n                    };\n                }\n            } else {\n                return {y: valueIsNumeric ? parseFloat(row[valueIndex]) : 0,\n                    category: row[categoryIndex],\n                    text: valueIsNumeric ? 'number' : row[valueIndex]};\n            }\n        }\n    }\n}\n\nfunction isNumber(value) {\n    return !isNaN(parseFloat(value));\n}\n\nfunction valueForCategoryAndSeries(dataRows, categoryIndex, categoryValue, seriesIndex, seriesValue, valueIndex) {\n\n    var rows = _.filter(dataRows, function(row) { return row[categoryIndex] === categoryValue && row[seriesIndex] === seriesValue });\n    return rows.length > 0 ? parseFloat(rows[0][valueIndex]) : 0;\n}\n\nfunction sortChartSeries(serieses) {\n\n    // check if these series are numerically sortable\n    var invalidSerieses = serieses.filter(function(series) {\n       return isNaN(toNumberSortValue(series.name))\n    });\n    if(invalidSerieses.length > 0) { return serieses; }\n\n    // if series sortable assign a sort value\n    serieses.forEach(function (series) {\n        series.name_value = toNumberSortValue(series.name);\n    });\n\n    // return the sorted series\n    return _.sortBy(serieses, function (series) {\n        return series.name_value;\n    })\n}\n\nfunction toNumberSortValue(value) {\n    var floatVal = parseFloat(value);\n    if(isNaN(floatVal)) {\n    return parseFloat(value.substring(1));\n    } else {\n    return floatVal;\n    }\n}\n\nfunction isUndefinedOrNull(value) {\n    return value === undefined || value === null;\n}\n\nfunction getIndices(headerRow, category_column, secondary_column, parent_column, order_column, custom_column) {\n    var headersLower = _.map(headerRow, function(item) { return item.toLowerCase();});\n\n    var category = isUndefinedOrNull(category_column) ? null: headersLower.indexOf(category_column.toLowerCase());\n    var order = isUndefinedOrNull(order_column) ? category : headersLower.indexOf(order_column.toLowerCase());\n    var parent = isUndefinedOrNull(parent_column) ? null: headersLower.indexOf(parent_column.toLowerCase());\n    var secondary = isUndefinedOrNull(secondary_column) ? null: headersLower.indexOf(secondary_column.toLowerCase());\n    var custom = isUndefinedOrNull(custom_column) ? null: headersLower.indexOf(custom_column.toLowerCase());\n\n    return {\n        'category': category >= 0 ? category : null,\n        'order': order >= 0 ? order : null,\n        'secondary': secondary >= 0 ? secondary : null,\n        'value': headersLower.indexOf('value'),\n        'parent': parent >= 0 ? parent : null,\n        'custom': custom >= 0 ? custom : null\n    };\n}\n\n// If we're running under Node - required for testing\nif(typeof exports !== 'undefined') {\n    var _ = require('../charts/vendor/underscore-min');\n    var dataTools = require('../charts/rd-data-tools');\n    var uniqueDataInColumnMaintainOrder = dataTools.uniqueDataInColumnMaintainOrder;\n\n    exports.barchartObject = barchartObject;\n    exports.linechartObject = linechartObject;\n    exports.componentChartObject = componentChartObject;\n    exports.panelLinechartObject = panelLinechartObject;\n    exports.panelBarchartObject = panelBarchartObject;\n}\n","/**\n * Created by Tom.Ridd on 25/07/2017.\n */\nvar NONE_VALUE = '[None]';\n\nfunction buildTableObject(data, title, subtitle, footer, row_column, parent_column, group_column, order_column, data_columns, column_captions, first_column_caption, group_order_column) {\n    var table = null;\n    if(!group_column || group_column === NONE_VALUE) {\n        table = simpleTable(data, title, subtitle, footer, row_column, parent_column, data_columns, order_column, column_captions, first_column_caption);\n    } else {\n        table = groupedTable(data, title, subtitle, footer, row_column, parent_column, group_column, data_columns, order_column, column_captions, first_column_caption, group_order_column);\n    }\n    return preProcessTableObject(table);\n}\n\nfunction simpleTable(data, title, subtitle, footer, category_column, parent_column, data_columns, order_column, column_captions, first_column_caption) {\n    var dataRows = _.clone(data);\n    var headerRow = dataRows.shift();\n\n    var columnIndex = headerRow.indexOf(category_column);\n    var data_column_indices = _.map(data_columns, function(data_column) { return headerRow.indexOf(data_column); });\n\n    var parentIndex = columnIndex;\n    var hasParentChild = false;\n    if(parent_column && parent_column !== NONE_VALUE) {\n        parentIndex = headerRow.indexOf(parent_column);\n        hasParentChild = true;\n    }\n\n    if(order_column && order_column !== NONE_VALUE) {\n        var sortIndex = headerRow.indexOf(order_column);\n    }\n\n    var tableData = _.map(dataRows, function(item, index) {\n        var relationships = {\n                'is_parent':false,\n                'is_child':false,\n                'parent':item[columnIndex]\n        };\n        if(hasParentChild) {\n            var parent = item[parentIndex];\n            var child = item[columnIndex];\n            relationships = {\n                'is_parent': parent === child,\n                'is_child': parent !== child,\n                'parent': parent\n            }\n        }\n\n        var values = _.map(data_column_indices, function (i) { return item[i]; });\n        var sortValues = _.map(values, function (value) { return numVal(value); });\n\n        if(sortIndex) {\n            return {\n                'category': item[columnIndex],\n                'relationships': relationships,\n                'order': item[sortIndex],\n                'values': values,\n                'sort_values': sortValues\n            };\n        } else {\n            return {\n                'category': item[columnIndex],\n                'relationships': relationships,\n                'order': index,\n                'values': values,\n                'sort_values': sortValues\n            };\n        }\n    });\n\n    tableData = _.sortBy(tableData, function(item) { return item['order'];});\n\n    if(hasParentChild) {\n        tableData = adjustSimpleTableDataForParents(tableData);\n    }\n\n    var first_column = first_column_caption == null ? category_column : first_column_caption;\n\n    return {\n        'type':'simple',\n        'parent_child': hasParentChild,\n        'header': title,\n        'subtitle' :subtitle,\n        'footer' :footer,\n        'category':category_column,\n        'columns': column_captions,\n        'data': tableData,\n        'category_caption': first_column\n    };\n}\n\nfunction buildDataObjects(group_values, dataRows, group_column_index, columnIndex, hasParentChild, parentIndex, sortIndex, DEFAULT_SORT, data_column_indices) {\n    return _.map(group_values, function (group) {\n        var group_data = _.filter(dataRows, function (item) {\n            return item[group_column_index] === group;\n        });\n        var group_data_items = _.map(group_data, function (item, index) {\n            var relationships = {\n                'is_parent': false,\n                'is_child': false,\n                'parent': item[columnIndex]\n            };\n            if (hasParentChild) {\n                var parent = item[parentIndex];\n                var child = item[columnIndex];\n                relationships = {\n                    'is_parent': parent === child,\n                    'is_child': parent !== child,\n                    'parent': parent\n                }\n            }\n            var sort_val = sortIndex === DEFAULT_SORT ? index : item[sortIndex];\n            var values = _.map(data_column_indices, function (i) {\n                return item[i]\n            });\n            var sortValues = _.map(values, function (value) {\n                return numVal(value);\n            });\n            return {\n                'category': item[columnIndex],\n                'relationships': relationships,\n                'order': sort_val,\n                'values': values,\n                'sort_values': sortValues\n            }\n        });\n        return {'group': group, 'data': group_data_items};\n    });\n}\nfunction templateGroupTable(category_column, title, column_captions, group_series) {\n    return {\n        'type': 'grouped',\n        'category': category_column,\n        'title': {'text': 'Grouped Table'},\n        'header': title,\n        'columns': column_captions,\n        'groups': group_series\n    };\n}\nfunction getDataByGroup(data_by_row, group_column_index, group_order_column, headerRow) {\n    var group_values = uniqueDataInColumnMaintainOrder(data_by_row, group_column_index);\n    if (group_order_column && group_order_column !== NONE_VALUE) {\n        var group_order_index = headerRow.indexOf(group_order_column);\n        var order_values = _.map(group_values, function (item) {\n            var index = _.findIndex(data_by_row, function (row) {\n                return row[group_column_index] === item;\n            });\n            return data_by_row[index][group_order_index];\n        });\n        group_values = _.map(_.sortBy(_.zip(group_values, order_values), function (pair) {\n            return pair[1];\n        }), function (pair) {\n            return pair[0];\n        });\n    }\n    return group_values;\n}\n\nfunction groupedTable(data, title, subtitle, footer,  category_column, parent_column, group_column, data_columns, order_column, column_captions, first_column_caption, group_order_column) {\n    var DEFAULT_SORT = -2;\n    var data_by_row = _.clone(data);\n    var headerRow = data_by_row.shift();\n\n\n    // ------------------- FIND INDICES FOR THE COLUMNS --------------------------\n\n    var columnIndex = headerRow.indexOf(category_column);\n    var data_column_indices = _.map(data_columns, function(data_column) { return headerRow.indexOf(data_column); });\n\n    var group_column_index = headerRow.indexOf(group_column);\n\n    var sortIndex = DEFAULT_SORT;\n    if (order_column === null) {\n        sortIndex = columnIndex;\n    } else if(order_column !== NONE_VALUE) {\n        sortIndex = headerRow.indexOf(order_column);\n    }\n\n    var parentIndex = columnIndex;\n    var hasParentChild = false;\n    if(parent_column && parent_column !== NONE_VALUE) {\n        parentIndex = headerRow.indexOf(parent_column);\n        hasParentChild = true;\n    }\n\n\n    // ----------------------- CONVERT TO DATA ITEM OBJECTS ----------------------\n    var data_by_group = getDataByGroup(data_by_row, group_column_index, group_order_column, headerRow);\n    var data_items_by_group = buildDataObjects(data_by_group, data_by_row, group_column_index, columnIndex, hasParentChild, parentIndex, sortIndex, DEFAULT_SORT, data_column_indices);\n\n\n    // ----------------------- ADJUSTMENTS FOR PARENT CHILD ----------------------\n    data_items_by_group = adjustGroupedTableDataForParents(data_items_by_group);\n\n    // --------------------- DATA VALUES (Values by row) -------------------------\n\n    var partial_table = templateGroupTable(category_column, title, column_captions, data_items_by_group);\n\n    var group_columns = [''].concat(_.map(partial_table.groups, function (group) { return group.group; } ));\n\n    var row_categories = _.map(partial_table.groups[0].data, function(item) { return item.category; });\n    var table_data = _.map(row_categories, function(category) { return dataItemWithCategory(partial_table, category); });\n    table_data = _.sortBy(table_data, function(item) { return item['order'];});\n\n    data_items_by_group = _.map(data_items_by_group, function (group) {\n        group.data = _.sortBy(group.data, function(item) { return item['order'];});\n        return group;\n    });\n\n\n    // --------------------- COMPLETE THE TABLE OBJECT --------------------------\n    var first_column = first_column_caption == null ? category_column : first_column_caption;\n\n    return {\n        'group_columns': group_columns,\n        'type':'grouped',\n        'category': category_column,\n        'group_column': group_column,\n        'columns': column_captions,\n        'data': table_data,\n        'header':title,\n        'subtitle':subtitle,\n        'footer':footer,\n        'groups': data_items_by_group,\n        'parent_child': hasParentChild,\n        'category_caption': first_column\n    };\n}\n\nfunction dataItemWithCategory(partial_table_object, category) {\n    var values = [];\n    var sortValue = '';\n    var parentValue = '';\n    var relationships = {};\n\n    _.forEach(partial_table_object.groups, function (group) {\n        var category_item = _.findWhere(group.data, {'category': category});\n        sortValue = category_item['order'];\n        parentValue = category_item['parent'];\n        relationships = category_item['relationships'];\n        _.forEach(category_item.values, function (cell) {\n            values.push(cell);\n        })\n    });\n\n    var sortValues = _.map(values, function (val) { return numVal(val);});\n\n    return {\n        'category': category,\n        'relationships': relationships,\n        'parent': parentValue,\n        'order': sortValue,\n        'values': values,\n        'sort_values': sortValues\n    };\n}\n\nfunction getColumnIndex(headerRow, column_name) {\n    if(parent_column && parent_column !== NONE_VALUE) {\n        return headerRow.indexOf(column_name);\n    } else {\n        return null;\n    }\n}\n\nfunction columnDecimalPlaces(tableObject) {\n    var dps = [];\n    // iterate through columns\n    for(var i in tableObject.data[0].values) {\n\n        // gather all the data for that column\n        var series = _.map(tableObject.data, function(item) {\n            return item.values[i];\n        });\n        dps.push(seriesDecimalPlaces(series));\n    }\n    return dps;\n}\n\nfunction columnCouldBeAYear(tableObject) {\n    var years = [];\n\n    // iterate through columns\n    for(var i in tableObject.data[0].values) {\n\n        // gather all the data for that column\n        var series = _.map(tableObject.data, function(item) { return item.values[i]; });\n        years.push(seriesCouldBeYear(series));\n    }\n    return years;\n}\n\nfunction groupedTableDecimalPlaces(tableObject) {\n    var dps = [];\n    // iterate through columns\n    for(var c in tableObject.groups[0].data[0].values) {\n\n        // gather all data for a column\n        var series = _.flatten(\n            _.map(tableObject.groups, function(group) {\n                return _.map(group.data, function(item) {\n                    return item.values[c];\n            })\n        }));\n        dps.push(seriesDecimalPlaces(series));\n    }\n    return dps;\n}\n\nfunction groupedTableCouldBeAYear(tableObject) {\n    var years = [];\n    // iterate through columns\n    for(var c in tableObject.groups[0].data[0].values) {\n\n        // gather all data for a column\n        var series = _.flatten(\n            _.map(tableObject.groups, function(group) {\n                return _.map(group.data, function(item) {\n                    return item.values[c];\n            })\n        }));\n        years.push(seriesCouldBeYear(series));\n    }\n    return years;\n}\n\nfunction preProcessTableObject(tableObject) {\n    if(tableObject.type === 'simple') {\n        preProcessSimpleTableObject(tableObject);\n    } else if(tableObject.type === 'grouped') {\n        preProcessGroupedTableObject(tableObject);\n    }\n    return tableObject;\n}\n\nfunction preProcessSimpleTableObject(tableObject) {\n    var columnDps = columnDecimalPlaces(tableObject);\n    var couldBeYear = columnCouldBeAYear(tableObject);\n\n    tableObject.data = _.map(tableObject.data, function(item) {\n        item.values = _.map(_.zip(item.values, columnDps, couldBeYear), function(cellTuple) {\n            if(cellTuple[2] === false) {\n                return formatNumberWithDecimalPlaces(cellTuple[0], cellTuple[1]);\n            } else {\n                return cellTuple[0];\n            }\n        });\n        return item;\n    });\n}\n\nfunction preProcessGroupedTableObject(tableObject) {\n    var columnDps = groupedTableDecimalPlaces(tableObject);\n    var couldBeYear = groupedTableCouldBeAYear(tableObject);\n\n\n    tableObject.groups = _.map(tableObject.groups, function(group) {\n        group.data = _.map(group.data, function(item) {\n           item.values = _.map(_.zip(item.values, columnDps, couldBeYear), function(cellTuple) {\n                if(cellTuple[2] === false) {\n                    return formatNumberWithDecimalPlaces(cellTuple[0], cellTuple[1]);\n                } else {\n                    return cellTuple[0];\n                }\n            });\n            return item;\n        });\n        return group;\n    });\n\n    // update tableObject data\n    tableObject.data = [];\n    // for each row\n    for(var rowNo in tableObject.groups[0].data) {\n        // grab a prototype cell\n        var row = _.clone(tableObject.groups[0].data[rowNo]);\n        // fill it with all contents across the groups\n        row.values = _.flatten(_.map(tableObject.groups, function(group) {\n            return group.data[rowNo].values;\n        }));\n        row.sort_values = _.flatten(_.map(tableObject.groups, function(group) {\n            return group.data[rowNo].sort_values;\n        }));\n        // add to the data\n        tableObject.data.push(row)\n    }\n\n\n    var items = _.sortBy(tableObject.groups[0].data, function(item) { return item.order; });\n    var rows = _.map(items, function(item) { return item.category; });\n    _.forEach(rows, function(row) {\n        var row_html = '<tr><th>' + row + '</th>';\n        _.forEach(tableObject.groups, function(group) {\n            var row_item = _.findWhere(group.data, {'category':row});\n            _.forEach(_.zip(row_item.values, columnDps, couldBeYear), function(cellValues) {\n                if(cellValues[2]) {\n                    row_html = row_html + '<td>' + cellValues[0] + '</td>';\n                } else {\n                    row_html = row_html + '<td>' + formatNumberWithDecimalPlaces(cellValues[0], cellValues[1]) + '</td>';\n                }\n            });\n        });\n    });\n}\n\nfunction numVal(value, defaultVal) {\n    var string = String(value).replace(/\\,/g, '')\n    var num = Number(string);\n    return num ? num : value;\n}\n\nfunction addMissingSimpleTableParentItems(tableData) {\n\n    var parents = _.uniq(_.map(tableData, function (item) {\n        return item['relationships']['parent'];\n    }));\n\n    var current_categories = _.map(tableData, function (item) {\n        return item['category'];\n    });\n    var missing_parents = _.filter(parents, function (parent) {\n        return !_.contains(current_categories, parent);\n    });\n\n    var newData = _.clone(tableData);\n    var example = tableData[0];\n    _.forEach(missing_parents, function (missing_parent) {\n\n        // find order for the new parent by finding the minimum value for it's children and subtracting 1\n        var parent_items = _.filter(tableData, function(item) { return item.relationships.parent === missing_parent; });\n        var min_order = _.min(_.map(parent_items, function(item) { return item.order; })) - 1;\n\n        var new_data_point = {\n            'category': missing_parent,\n            'order': min_order,\n            'relationships': {'is_child': false, 'is_parent': true, 'parent': missing_parent},\n            'sort_values': _.map(example['sort_values'], function (value) {\n                return 0;\n            }),\n            'values': _.map(example.values, function (value) {\n                return '';\n            })\n        };\n        newData.push(new_data_point);\n    });\n\n    return newData;\n}\nfunction adjustSimpleTableDataForParents(tableData) {\n    var fullData = addMissingSimpleTableParentItems(tableData);\n    return reorderSimpleTableDataForParentChild(fullData);\n}\n\nfunction reorderSimpleTableDataForParentChild(tableData) {\n    var item_dict = _.object(_.map(tableData, function(item) { return [item.category, item]; }));\n    var parents = _.uniq(_.map(tableData, function(item) { return item['relationships']['parent']; }));\n\n    var ordered_data = [];\n    _.forEach(parents, function(parent) {\n        ordered_data.push(item_dict[parent]);\n        var parent_children = _.filter(tableData, function(item) { return item['category'] !== parent && item['relationships']['parent'] === parent; });\n        ordered_data = ordered_data.concat(parent_children);\n    });\n    return ordered_data;\n}\n\nfunction adjustGroupedTableDataForParents(tableData) {\n    var fullData = addMissingGroupedTableParentItems(tableData);\n    return reorderGroupedTableDataForParentChild(fullData);\n}\n\nfunction addMissingGroupedTableParentItems(tableData) {\n\n    // Find all existing parents\n    var parents = _.uniq(\n        _.flatten(\n        _.map(tableData, function (column) {\n            return _.map(column.data, function(cell) {\n               return cell.relationships.parent\n            });\n        }\n        )\n    ));\n\n    // Find all existing rows\n    var current_categories = _.uniq(\n        _.flatten(\n        _.map(tableData, function (column) {\n            return _.map(column.data, function(cell) {\n               return cell.category\n            });\n        }\n        )\n    ));\n\n    // Find rows that need to be added\n    var missing_parents = _.filter(parents, function (parent) {\n        return !_.contains(current_categories, parent);\n    });\n\n    // Build the new data items\n    var newData = _.clone(tableData);\n    var example = tableData[0].data[0];\n    _.forEach(missing_parents, function (missing_parent) {\n\n        // find order for the new parent by finding the minimum value for it's children and subtracting 1\n        var parent_items = _.filter(_.flatten(_.map(tableData, function(column) { return column.data})), function(item) { return item.relationships.parent === missing_parent; });\n        var min_order = _.min(_.map(parent_items, function(item) { return item.order; })) - 1;\n\n        // build the new data points\n        _.forEach(newData, function(group) {\n            var new_data_point = {\n                'category': missing_parent,\n                'order': min_order,\n                'relationships': {'is_child': false, 'is_parent': true, 'parent': missing_parent},\n                'sort_values': _.map(example['sort_values'], function (value) {\n                    return 0;\n                }),\n                'values': _.map(example.values, function (value) {\n                    return '';\n                })\n            };\n            group.data.push(new_data_point)\n        });\n    });\n\n    return newData;\n}\n\nfunction reorderGroupedTableDataForParentChild(tableData) {\n    var item_dict = _.object(_.map(tableData, function(item) { return [item.category, item]; }));\n    var parents = _.uniq(\n        _.flatten(\n        _.map(tableData, function (column) {\n            return _.map(column.data, function(cell) {\n               return cell.relationships.parent\n            });\n        }\n        )\n    ));\n\n    _.forEach(tableData, function(group) {\n        var item_dict = _.object(_.map(group.data, function(item) { return [item.category, item]; }));\n        var ordered_data = [];\n        _.forEach(parents, function(parent) {\n            ordered_data.push(item_dict[parent]);\n            var parent_children = _.filter(group.data, function(item) { return item['category'] !== parent && item['relationships']['parent'] === parent; });\n            ordered_data = ordered_data.concat(parent_children);\n        });\n        group.data = ordered_data;\n    });\n\n    return tableData;\n}\n\n// If we're running under Node - required for testing\nif(typeof exports !== 'undefined') {\n    var _ = require('../charts/vendor/underscore-min');\n    var dataTools = require('../charts/rd-data-tools');\n    var uniqueDataInColumnMaintainOrder = dataTools.uniqueDataInColumnMaintainOrder;\n    var seriesDecimalPlaces = dataTools.seriesDecimalPlaces;\n    var seriesCouldBeYear = dataTools.seriesCouldBeYear;\n    var formatNumberWithDecimalPlaces = dataTools.formatNumberWithDecimalPlaces;\n\n    exports.buildTableObject = buildTableObject;\n    exports.simpleTable = simpleTable;\n    exports.groupedTable = groupedTable;\n}","/**\n * Created by Tom.Ridd on 05/05/2017.\n */\n\nfunction drawTable(container_id, tableObject) {\n\n    preProcessTableObject(tableObject);\n\n    if(tableObject.type === 'simple') {\n        return simpleHtmlTable(container_id, tableObject);\n    } else if (tableObject.type === 'grouped') {\n        return groupedHtmlTable(container_id, tableObject);\n    }\n}\n\nfunction simpleHtmlTable(container_id, tableObject) {\n\n    var table_html = \"\";\n    table_html = appendTableTitle(table_html, tableObject);\n    table_html = appendTableSubtitle(table_html, tableObject);\n\n    table_html = table_html + \"<table class='table table-sm'>\";\n    table_html = appendSimpleTableHeader(table_html, tableObject);\n    table_html = appendSimpleTableBody(table_html, tableObject);\n    table_html = table_html + \"</table>\";\n\n    $(\"#\" + container_id).html(table_html);\n\n    return true;\n}\n\nfunction groupedHtmlTable(container_id, tableObject) {\n\n    var table_html = \"\";\n    table_html = appendTableTitle(table_html, tableObject);\n    table_html = appendTableSubtitle(table_html, tableObject);\n\n    table_html = table_html + \"<table class='table table-sm'>\";\n    table_html = appendGroupTableHeader(table_html, tableObject);\n    table_html = appendGroupedTableBody(table_html, tableObject)\n    table_html = table_html + \"</table>\";\n\n    table_html = insertTableFooter(table_html, tableObject);\n\n    $(\"#\" + container_id).html(table_html);\n\n    return true;\n}\n\nfunction appendSimpleTableBody(table_html, tableObject) {\n    var body_html = \"<tbody>\";\n    _.forEach(tableObject.data, function(item) {\n        body_html = body_html + \"<tr>\";\n        if(tableObject.parent_child) {\n            if(item.relationships.is_parent) {\n                body_html = body_html + '<th class=\"parent_row\">'\n            } else {\n                body_html = body_html + '<th class=\"child_row\">'\n            }\n        } else {\n            body_html = body_html + '<th>'\n        }\n        body_html = body_html + item.category + '</th>';\n\n        _.forEach(item.values, function(cellValue) {\n            body_html = body_html + '<td>' + cellValue + '</td>';\n        });\n        body_html = body_html + \"</tr>\";\n    });\n    body_html = body_html + \"</tbody>\";\n    return table_html + body_html;\n}\n\nfunction appendGroupedTableBody(table_html, tableObject) {\n    var body_html = '<tbody>';\n\n    var items = _.sortBy(tableObject.groups[0].data, function(item) { return item.order; });\n\n    _.forEach(items, function(item) {\n        var row = item.category;\n        var row_html = '<tr>';\n        if(tableObject.parent_child) {\n            if(item.relationships.is_parent) {\n                row_html = row_html + '<th class=\"parent_row\">'\n            } else {\n                row_html = row_html + '<th class=\"child_row\">'\n            }\n        } else {\n            row_html = row_html + '<th>'\n        }\n        row_html = row_html + row + '</th>';\n\n        _.forEach(tableObject.groups, function(group) {\n            var row_item = _.findWhere(group.data, {'category':row});\n            _.forEach(row_item.values, function(cellValue) {\n                row_html = row_html + '<td>' + cellValue + '</td>';\n            });\n        });\n        row_html = row_html + '</tr>';\n        body_html = body_html + row_html;\n    });\n    body_html = body_html + \"</tbody>\";\n    return table_html + body_html;\n}\n\nfunction appendTableTitle(table_html, tableObject) {\n    if(tableObject.header && tableObject.header !== '') {\n        return table_html + \"<div class='table-title heading-small'>\" + tableObject.header + \"</div>\";\n    } else {\n        return table_html;\n    }\n}\n\nfunction insertTableFooter(table_html, tableObject) {\n    if(tableObject.footer && tableObject.footer !== '') {\n        return table_html + \"<div class='table-footer'>\" + tableObject.footer + \"</div>\";\n    } else {\n        return table_html;\n    }\n}\n\nfunction appendTableSubtitle(table_html, tableObject) {\n    if(tableObject.subtitle && tableObject.subtitle !== '') {\n        return table_html + \"<div class='table-subtitle'>\" + tableObject.subtitle + \"</div>\";\n    } else {\n        return table_html;\n    }\n}\n\nfunction appendSimpleTableHeader(table_html, tableObject) {\n    var header_html = \"\";\n    if(tableObject['category_caption'] == null) {\n        header_html = \"<thead><tr><th></th>\";\n    } else {\n        header_html = \"<thead><tr><th>\" + tableObject.category_caption + \"</th>\";\n    }\n\n    _.forEach(tableObject.columns, function(column) {\n        header_html = header_html + '<th>' + column + '</th>';\n    });\n    header_html = header_html + \"</tr></thead>\"\n    return table_html + header_html;\n}\n\nfunction appendGroupTableHeader(table_html, tableObject) {\n    var header_html = '';\n    if(tableObject['category_caption'] == null) {\n        header_html = \"<thead><tr><th></th>\";\n    } else {\n        header_html = \"<thead><tr><th>\" + tableObject.category_caption + \"</th>\";\n    }\n\n    // Add a row with titles for each group\n    _.forEach(tableObject.groups, function (group) {\n        header_html = header_html + multicell(group.group, tableObject.columns.length);\n    });\n    header_html = header_html + '</tr>';\n\n    // Check if we need to add a second row (based if any column headings exist)\n    var doSecondRow = false;\n    _.forEach(tableObject.columns, function(column) {\n        if(column !== '') {\n            doSecondRow = true;\n        }\n    });\n\n    // If a second row is required add it\n    if(doSecondRow) {\n        header_html = header_html + '<tr><td></td>';\n        _.forEach(tableObject.groups, function (group) {\n            _.forEach(tableObject.columns, function(column) {\n                header_html = header_html + '<td>' + column + '</td>';\n            });\n        });\n        header_html = header_html + '</tr>';\n    }\n\n    header_html = header_html + '</thead>';\n\n    return table_html + header_html;\n}\n\nfunction multicell(text, total_cells) {\n    return '<td colspan=' + total_cells + '>' + text + '</td>';\n}","$(document).ready(function () {\n  var $stickies = $(\".sticky-js\");\n  $.each($stickies, function () {\n    var stickyPosition = parseInt($(this).position().top);\n    $(window).scroll(function () {\n      var scrollTop = $(window).scrollTop();\n      if (scrollTop >= stickyPosition) {\n        $(this).addClass('sticky-js-fixed');\n      } else {\n        $(this).removeClass('sticky-js-fixed');\n      }\n    }.bind(this));\n  });\n});"],"sourceRoot":"../src"}